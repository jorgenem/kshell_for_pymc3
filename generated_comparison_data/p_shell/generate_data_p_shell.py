import sys
import os
import shutil
import numpy as np

sys.path.insert(0, "../../")
# Import settings from kshell_settings.py:
from kshell_settings import KSHELL_DIR, IS_MPI
# Then import utility scripts from KSHELL_DIR/bin folder:
sys.path.insert(0, os.path.join(KSHELL_DIR, "bin"))
import shellmodelcalculation as smcalc
import shellmodelutilities as smutil


def sum_num_levels(levels):
    N = 0
    for level in levels:
        # print level
        N += int(level[4:])
    return N


def max_num_levels(levels):
    maxval = 0
    for level in levels:
        # print level, level[4:]
        if int(level[4:]) > maxval:
            maxval = int(level[4:])
    return maxval

# def scale_TBME(TBME,A,A0,p=0.3):
#     TBME_copy = np.copy(TBME)
#     TBME_copy[:,5] = (A0/A)**p * TBME_copy[:,5]
#     return TBME_copy


# ==== Set up nuclei ======
truncation = [[],[]] # Truncations of the form [[orbital_numbers], [min_part1, max_part1, min_part2, max_part2, ...]]

# Use the file ckpot.snt to generate data for the p shell:
SPE, TBME, model_space, core = smutil.read_interaction_file(
    os.path.join(KSHELL_DIR, "snt/ckpot.snt"))

nucleiList = { 
    # This list of nuclei is generated using the extract_level_info_from_RIPL.py script to get spin, parity information. 
    # The selection is based on manually going throught ENSDF entries,
    # stopping before unnatural-parity or undetermined levels
     "B10": {"A":10, "Z":5, "levels":["3.0+2","0.0+1","1.0+2","2.0+1",], "truncation":truncation},
     "B11": {"A":11, "Z":5, "levels":["3.5-1","0.5-1","2.5-1","1.5-2",], "truncation":truncation},
     "B12": {"A":12, "Z":5, "levels":["1.0+1","2.0+1",], "truncation":truncation},
     "B9": {"A":9, "Z":5, "levels":["1.5-1",], "truncation":truncation},
     "Be10": {"A":10, "Z":4, "levels":["0.0+1","2.0+2",], "truncation":truncation},
     "Be6": {"A":6, "Z":4, "levels":["0.0+1",], "truncation":truncation},
     "Be7": {"A":7, "Z":4, "levels":["3.5-2","0.5-2","2.5-2","1.5-3",], "truncation":truncation},
     "Be8": {"A":8, "Z":4, "levels":["0.0+1","1.0+2","2.0-1","4.0+1","2.0+3",], "truncation":truncation},
     "Be9": {"A":9, "Z":4, "levels":["2.5+1","0.5+1","0.5-1","2.5-1","1.5-1",], "truncation":truncation},
     "C10": {"A":10, "Z":6, "levels":["0.0+1","2.0+1",], "truncation":truncation},
     "C11": {"A":11, "Z":6, "levels":["0.5-1","2.5-1","1.5-2",], "truncation":truncation},
     "C12": {"A":12, "Z":6, "levels":["0.0+2","2.0+1",], "truncation":truncation},
     "C13": {"A":13, "Z":6, "levels":["0.5-1",], "truncation":truncation},
     "C8": {"A":8, "Z":6, "levels":["0.0+1",], "truncation":truncation},
     "He5": {"A":5, "Z":2, "levels":["1.5-1",], "truncation":truncation},
     "He6": {"A":6, "Z":2, "levels":["0.0+1","2.0+1",], "truncation":truncation},
     "Li5": {"A":5, "Z":3, "levels":["1.5-1",], "truncation":truncation},
     "Li6": {"A":6, "Z":3, "levels":["3.0+2","0.0+1","1.0+2","2.0+2",], "truncation":truncation},
     "Li7": {"A":7, "Z":3, "levels":["3.5-2","0.5-1","2.5-2","1.5-3",], "truncation":truncation},
     "Li8": {"A":8, "Z":3, "levels":["3.0+1","1.0+3","2.0+1",], "truncation":truncation},
     "Li9": {"A":9, "Z":3, "levels":["1.5-1",], "truncation":truncation},
     "N12": {"A":12, "Z":7, "levels":["1.0+1","2.0+1",], "truncation":truncation},
     "N13": {"A":13, "Z":7, "levels":["0.5-1",], "truncation":truncation},
     "N14": {"A":14, "Z":7, "levels":["0.0+1","1.0+2",], "truncation":truncation},
}


smutil.write_interaction_file_msdict("interaction.snt", SPE, TBME, model_space, core, comments="Autogenerated by generate_data script.", mass_scaling=True, scaling_A0=4, scaling_p=-0.30)
# Make new dict containing instances of shellmodelcalculation class for each nucleus in nucleiList:
nuclei = {}
# Write interaction file:
for name, attr in nucleiList.iteritems():
    # TBME_current = scale_TBME(TBME, attr["A"], A0=16, p=0.3) # Apply mass scaling to TBMEs
    # nuclei[name] = smcalc.shellmodelcalculation(name, A=attr["A"], Z=attr["Z"], levels=attr["levels"], truncation=attr["truncation"], core=core, model_space=model_space, SPE=SPE, TBME=TBME, kshell_dir=KSHELL_DIR, calc_tbme=False, ensemble_run=True)
    nuclei[name] = smcalc.shellmodelcalculation(name, A=attr["A"], Z=attr["Z"], levels=attr["levels"], truncation=attr["truncation"], core=core, model_space=model_space, SPE=SPE, TBME=TBME, kshell_dir=KSHELL_DIR, calc_tbme=False, ensemble_run=False)
        

# Copy binary files to run directory:
fn_kshell = "kshell_mpi" if IS_MPI else "kshell"
fn_transit = "transit_mpi" if IS_MPI else "transit"
fn_collectlogs = "collect_logs.py"
if not (os.path.isfile(fn_kshell) and os.path.isfile(fn_transit) and os.path.isfile(fn_collectlogs)):
    try:
        shutil.copy(os.path.join(KSHELL_DIR, "bin/", fn_kshell),
                    os.path.join(os.path.realpath(__file__), "../"))  # Messy, but the directory structure is a little rigid in order to get this machinery to work right.
        shutil.copy(os.path.join(KSHELL_DIR, "bin/", fn_transit),
                    os.path.realpath(__file__))
        shutil.copy(os.path.join(KSHELL_DIR, "bin/", fn_collectlogs),
                    os.path.realpath(__file__))
    except IOError:
        print "\n*** WARNING: copying binary files to current dir. failed ***"


for nucleusName, nucleusSMC in nuclei.iteritems():
        # print "\n    ==== Now running {:s} ====    \n".format(nucleusName)
        # JEM 20171004: Changed n_restart_vec to vary based on max number of levels for each calculation in each nucleus. Added function to calculate said quantity.
        #                             TODO: Should consider letting n_restart_vec vary for each J,pi calculation within one nucleus, since this might save some computing time.
        #                                         That would require modifying the shellmodelcalculation class slightly.
        # print sum_num_levels(nucleusSMC.levels)
        # nucleusSMC.run(is_mpi="batch", n_restart_vec=int(1.5*max_num_levels(nucleusSMC.levels)), max_lanc_vec=(200+int(1.5*max_num_levels(nucleusSMC.levels)))) # Supercomputer
        nucleusSMC.run(is_mpi=IS_MPI, n_restart_vec=int(1.5*max_num_levels(nucleusSMC.levels)), max_lanc_vec=(200+int(1.5*max_num_levels(nucleusSMC.levels)))) # Laptop



